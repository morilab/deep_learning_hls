#include "test.h"


int main(void) {
	Matrix<1,3,int> z;

	//------------------------------------
	// setting input data (x)
	//------------------------------------
	int x[4] =
		{1,3,5,7};

	//------------------------------------
	// setting Parameter (bias,weight)
	//------------------------------------
	int bias[3] =
		{-1,0,1};

	int weight[3][4] = {
		{ 2, 2, 2, 2},
		{ 2, 2,-8,-4},
		{ 2,-1,-2, 2},
	};

	//------------------------------------
	// View Input data & Parameter
	//------------------------------------
	for(int i=0;i<4;i++){
		printf("x%d = %d\n",i,x[i]);
	}
	printf("\n");

	printf("Weight = {\n");
	for(int i=0;i<4;i++){
		printf("  {");
		for(int j=0;j<3;j++){
			printf(" %3d",weight[j][i]);
		}
		printf(" }\n");
	}
	printf("};\n\n");

	printf("Bias = {\n  {");
	for(int i=0;i<3;i++){
		printf(" %3d",bias[i]);
	}
	printf(" }\n};\n\n");

	//------------------------------------
	// run DeepLearning
	//------------------------------------
	z = deep_learning<4,3,int>(x, weight, bias);

	for(int i=0;i<3;i++){
		printf("u%d = %d\n",i,z(0,i));
	}



	//------------------------------------
	Matrix<28,28,int> inframe;

	// inframe初期化
	int inframe_2D[28][28] = {
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,1, 1,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,1,2, 3,1,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,2,4, 5,1,0,0,0,0,0, 0,0,0,0,0,0,0},

		{0,0,0,0,0,0,0, 0,0,0,0,0,1,9, 9,3,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,8, 9,2,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,9, 9,1,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,8, 9,1,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,1,9, 9,2,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,1,2,9, 9,1,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,1,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},

		{0,0,0,0,0,0,0, 0,0,0,0,0,0,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,1,9, 9,1,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,2,9, 9,2,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,3,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,3,9, 7,0,0,0,0,0,0, 0,0,0,0,0,0,0},

		{0,0,0,0,0,0,0, 0,0,0,0,0,4,9, 8,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,4,9, 9,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,1,5,9, 9,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,3,9, 9,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,1,9, 9,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,2,5, 4,0,0,0,0,0,0, 0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0, 0,0,0,0,0,0,1, 0,0,0,0,0,0,0, 0,0,0,0,0,0,0},
	};

	int filter[] = {
		0,1,1,1,2,
		0,2,5,2,1,
		0,2,5,2,1,
		0,2,5,5,1,
		1,0,0,0,0,
	};

	for(int y=0;y<28;y++){
		for(int x=0;x<28;x++){
			inframe(x,y) = inframe_2D[y][x];
		}
	}

	//------------------------------------
	// 畳み込みパーセプトロン単体試験
	//------------------------------------
	convolution_perceptron<28,28,5,5,int> tr;
	tr.set_filter(filter);
	tr.in = inframe;
	tr.Proc();
	tr.view_filter();
	tr.view_conv();
	tr.view_out();

	//------------------------------------
	// ディープラーニング試験
	//------------------------------------
	typedef ap_fixed<4, 4, AP_RND, AP_SAT> T;
	const int SIZE1 = 20;
	const int SIZE2 = 20;
	const int SIZE3 = 500;
	const int SIZE4 = 10;
	const int WINDOW_SIZE = 5*5;

	T L1_filter[SIZE1][WINDOW_SIZE];
	T L1_bias  [SIZE1];
	T L2_filter[SIZE2][SIZE1][WINDOW_SIZE];
	T L2_bias  [SIZE2][SIZE1];
	T L3_weight[SIZE3][SIZE2][7*7];
	T L3_bias  [SIZE3];
	T L4_weight[SIZE4][SIZE3];
	T L4_bias  [SIZE4];
	Matrix<28,28,T> in;
	Matrix<1,SIZE4,T> result;

	// inframeロード
	for(int y=0;y<28;y++){
		for(int x=0;x<28;x++){
			in(x,y) = inframe(x,y);
		}
	}
	// パラメータの初期化
	// Layer 1
	for(int i=0;i<SIZE1;i++){
		for(int j=0;j<WINDOW_SIZE;j++){
			L1_filter[i][j] = (T)(rand()%9-4);
		}
		L1_bias[i] = 0;
	}
	// Layer 2
	for(int i=0;i<SIZE2;i++){
		for(int j=0;j<SIZE1;j++){
			for(int k=0;k<WINDOW_SIZE;k++){
				L2_filter[i][j][k] = (T)(rand()%9-4);
			}
			L2_bias[i][j] = 0;
		}
	}
	// Layer 3
	for(int i=0;i<SIZE3;i++){
		for(int j=0;j<SIZE2;j++){
			for(int k=0;k<7*7;k++){
				L3_weight[i][j][k] = (T)(rand()%9-4);
			}
		}
		L3_bias[i] = 0;
	}
	// Layer 4
	for(int i=0;i<SIZE4;i++){
		for(int j=0;j<SIZE3;j++){
			L4_weight[i][j] = (T)(rand()%9-4);
		}
		L4_bias[i] = 0;
	}

	result = convolution_nn<28,28 ,5,5 ,SIZE1,SIZE2,SIZE3,SIZE4 ,T>
	         (in, L1_filter, L1_bias, L2_filter, L2_bias ,L3_weight ,L3_bias ,L4_weight ,L4_bias);

	return 0;
}
